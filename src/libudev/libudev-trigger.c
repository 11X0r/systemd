/* SPDX-License-Identifier: LGPL-2.1+ */

#include <errno.h>

#include "alloc-util.h"
#include "device-trigger-private.h"

#include "libudev-device-internal.h"
#include "libudev-enumerate-internal.h"
#include "libudev-list-internal.h"

/**
 * SECTION:libudev-trigger
 * @short_description: trigger synthetic udev events
 *
 * This is an interface for triggering synthetic udev events for
 * a set of given devices. The set is defined by adding individual
 * devices to the trigger or by providing a udev device enumeration
 * object.
 *
 * Synthetic udev events are generated by kernel, but unlike genuine
 * events, these are provoked by a userspace process. This technique
 * is used to notify all event listeners back in userspace on demand,
 * including udev daemon which then reexecutes all applicable udev
 * rules and it refreshes udev database accordigly.
 *
 * All synthetic udev events always contain compulsory SYNTH_UUID=<uuid>
 * pair in the event environment where the <uuid> is in the
 * xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx format. Libudev assigns a new
 * random <uuid> for each trigger execution.
 *
 * It is also possible to pass additional key-value pairs with the
 * trigger which are then inserted into the environment of the generated
 * synthetic udev events. All these additional key-value pairs are always
 * prefixed with a 'SYNTH_ARG_' prefix to avoid conflict with any other
 * keys. The key and value in 'SYNTH_ARG_<key>=<value>' pair is restricted
 * to alphanumeric characters only, that is [a-z], [A-Z], [0-9].
 *
 */

/**
 * udev_trigger:
 *
 * Opaque context object representing the trigger.
 */
struct udev_trigger {
        struct udev *udev;
        unsigned n_ref;
        struct udev_list *devices_list;
        struct udev_list *properties_list;
        bool devices_uptodate:1;
        bool properties_uptodate:1;

        sd_device_trigger *trigger;
};

static struct udev_trigger *udev_trigger_free(struct udev_trigger *udev_trigger) {
        sd_device_trigger_unref(udev_trigger->trigger);

        return mfree(udev_trigger);
}

/**
 * udev_trigger_ref:
 * @udev_trigger: udev trigger context
 *
 * Take a reference of a udev trigger context.
 *
 * Returns: passed udev trigger context
 **/

/**
 * udev_trigger_unref:
 * @udev_trigger: udev trigger context
 *
 * Drop a reference of a udev trigger context. If the refcount reaches zero,
 * all resources of the udev trigger context will be released.
 *
 * Returns: #NULL
 **/
DEFINE_PUBLIC_TRIVIAL_REF_UNREF_FUNC(struct udev_trigger, udev_trigger, udev_trigger_free);

struct udev *udev_trigger_get_udev(struct udev_trigger *udev_trigger) {
        assert_return_errno(udev_trigger, NULL, EINVAL);

        return udev_trigger->udev;
}

/**
 * udev_trigger_new
 * @udev: udev library context
 *
 * Create a trigger context to synthesize udev events.
 *
 * Returns: udev trigger context.
 */
_public_ struct udev_trigger *udev_trigger_new(struct udev *udev) {
        struct udev_trigger *udev_trigger;
        _cleanup_ (sd_device_trigger_unrefp) sd_device_trigger *trigger;
        int r;

        assert_return_errno(udev, NULL, EINVAL);

        r = sd_device_trigger_new(&trigger);
        if (r < 0)
                return_with_errno(NULL, r);

        r = sd_device_trigger_set_source(trigger, "UDEVLIB");
        if (r < 0)
                return_with_errno(NULL, r);

        udev_trigger = new(struct udev_trigger, 1);
        if (!udev_trigger)
                return_with_errno(NULL, ENOMEM);

        *udev_trigger = (struct udev_trigger) {
                .udev = udev,
                .n_ref = 1,
                .trigger = TAKE_PTR(trigger),
        };

        return udev_trigger;
}

/**
 * udev_trigger_set_action
 * @udev_trigger: udev trigger context
 * @action: action for the trigger, one of: add, change, remove, move, offline, online, bind, unbind.
 *
 * Set action to trigger udev events. Note that if the action is not set
 * explicitly by calling this function, then by default 'change' action
 * is used for the trigger.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_set_action(struct udev_trigger *udev_trigger, const char *action) {
        assert_return(udev_trigger, -EINVAL);

        return sd_device_trigger_set_action(udev_trigger->trigger, action);
}

/**
 * udev_trigger_get_action
 * @udev_trigger: udev trigger context
 *
 * Get action currently assigned to the trigger.
 *
 * Returns: action string
 */
_public_ const char *udev_trigger_get_action(struct udev_trigger *udev_trigger) {
        assert_return_errno(udev_trigger, NULL, EINVAL);

        return sd_device_trigger_get_action(udev_trigger->trigger);
}

/**
 * udev_trigger_set_source
 * @udev_trigger: udev trigger context
 * @source: source name
 *
 * Mark all synthesized udev events with source name. All the synthesized udev
 * events then contain SYNTH_ARG_SOURCE=source pair in their event environment.
 * Note that if the source name is not set explicitly by calling this function,
 * then by default 'SYNTH_ARG_SOURCE=UDEVLIB' pair is used.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_set_source(struct udev_trigger *udev_trigger, const char *source) {
        assert_return(udev_trigger, -EINVAL);

        return sd_device_trigger_set_source(udev_trigger->trigger, source);
}

/**
 * udev_trigger_get_source
 * @udev_trigger: udev trigger context
 *
 * Get source currently assigned to the trigger.
 *
 * Returns: source string
 */
_public_ const char *udev_trigger_get_source(struct udev_trigger *udev_trigger) {
        assert_return_errno(udev_trigger, NULL, EINVAL);

        return sd_device_trigger_get_source(udev_trigger->trigger);
}

/**
 * udev_trigger_get_uuid
 * @udev_trigger: udev trigger context
 *
 * Get the UUID which is used to mark all synthesized udev events
 * for devices when the trigger is executed. Each trigger execution
 * uses new automatically generated UUID. All the synthesized udev
 * events then contain SYNTH_UUID=UUID pair in their event environment.
 *
 * Returns: UUID used when the trigger is executed.
 */
_public_ const char *udev_trigger_get_uuid(struct udev_trigger *udev_trigger) {
        assert_return_errno(udev_trigger, NULL, EINVAL);

        return sd_device_trigger_get_uuid(udev_trigger->trigger);
}

/**
 * udev_trigger_add_device
 * @udev_trigger: udev trigger context
 * @udev_device: device to add for the trigger
 *
 * Add device to the trigger so when the trigger is executed, a udev event
 * is synthesized for this device.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_add_device(struct udev_trigger *udev_trigger, struct udev_device *udev_device) {
        int r;

        assert_return(udev_trigger, -EINVAL);

        r = sd_device_trigger_add_device(udev_trigger->trigger, udev_device_get_sd_device(udev_device));
        if (r < 0)
                return r;

        udev_trigger->devices_uptodate = false;
        return 0;
}

/**
 * udev_trigger_add_device
 * @udev_trigger: udev trigger context
 * @udev_enumerate: device enumeration context
 *
 * Add all enumerated devices to the trigger so when the trigger is executed,
 * a udev event is synthesized for each device.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_add_enumerate(struct udev_trigger *udev_trigger, struct udev_enumerate *udev_enumerate) {
        int r;

        assert_return(udev_trigger, -EINVAL);
        assert_return(udev_enumerate, -EINVAL);

        r = sd_device_trigger_add_enumerator(udev_trigger->trigger, udev_enumerate_get_sd_enumerator(udev_enumerate));
        if (r < 0)
                return r;

        udev_trigger->devices_uptodate = false;
        return 0;
}

/**
 * udev_trigger_get_devices_list_entry
 * @udev_trigger: udev trigger context
 *
 * Get the first entry of the sorted list of device paths included in the trigger.
 *
 * Returns: udev list entry.
 */
_public_ struct udev_list_entry *udev_trigger_get_devices_list_entry(struct udev_trigger *udev_trigger) {
        sd_device **devices;
        size_t n_devices;
        size_t i;
        struct udev_list_entry *e;

        assert_return_errno(udev_trigger, NULL, EINVAL);

        if (!udev_trigger->devices_uptodate) {
                devices = device_trigger_get_devices(udev_trigger->trigger, &n_devices);
                if (!devices || !n_devices)
                        return NULL;

                udev_list_cleanup(udev_trigger->devices_list);

                for (i = 0; i < n_devices; i++) {
                        const char *syspath;
                        int r;

                        r = sd_device_get_syspath(devices[i], &syspath);
                        if (r < 0)
                                return_with_errno(NULL, r);

                        if (!udev_list_entry_add(udev_trigger->devices_list, syspath, NULL))
                                return_with_errno(NULL, ENOMEM);
                }

                udev_trigger->devices_uptodate = true;
        }

        e = udev_list_get_entry(udev_trigger->devices_list);
        if (!e)
                return_with_errno(NULL, ENODATA);

        return e;
}

/**
 * udev_trigger_add_property
 * @udev_trigger: udev trigger context
 * @key: property key (alphanumeric characters [a-z,A-Z,0-9] allowed only)
 * @value: property value (alphanumeric characters [a-z,A-Z,0-9] allowed only)
 *
 * Add key-value pair to include for all synthesized udev events for
 * devices when the trigger is executed. All the synthesized udev
 * events then contain SYNTH_ARG_KEY=VALUE pair in their event environment.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_add_property(struct udev_trigger *udev_trigger, const char *key, const char *value) {
        int r;

        assert_return(udev_trigger, -EINVAL);
        assert_return(key, -EINVAL);
        assert_return(value, -EINVAL);

        r = sd_device_trigger_add_property(udev_trigger->trigger, key, value);
        if (r < 0)
                return r;

        udev_trigger->properties_uptodate = false;
        return 0;
}

/**
 * udev_trigger_get_properties_list_entry
 * @udev_trigger: udev trigger context
 *
 * Get the first entry of the sorted list of properties included in the trigger.
 *
 * Returns: udev list entry.
 */
_public_ struct udev_list_entry *udev_trigger_get_properties_list_entry(struct udev_trigger *udev_trigger) {
        Hashmap *h;
        Iterator i;
        struct udev_list_entry *e;

        assert_return_errno(udev_trigger, NULL, EINVAL);

        if (!udev_trigger->properties_uptodate) {
                const char *key;
                const char *value;

                h = device_trigger_get_properties(udev_trigger->trigger);
                if (!h)
                        return NULL;

                udev_list_cleanup(udev_trigger->properties_list);

                HASHMAP_FOREACH_KEY(value, key, h, i)
                       if (!udev_list_entry_add(udev_trigger->properties_list, key, value))
                               return_with_errno(NULL, ENOMEM);

                udev_trigger->properties_uptodate = true;
        }

        e = udev_list_get_entry(udev_trigger->properties_list);
        if (!e)
                return_with_errno(NULL, ENODATA);

        return e;
}

/**
 * udev_trigger_execute
 * @udev_trigger: udev trigger context
 *
 * Execute the trigger, causing the synthesized udev events to be generated for all
 * devices included in the trigger.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_execute(struct udev_trigger *udev_trigger) {
        assert_return(udev_trigger, -EINVAL);

        return sd_device_trigger_execute(udev_trigger->trigger);
}

/**
 * udev_trigger_execute_with_settle
 * @udev_trigger: udev trigger context
 * @timeout_sec: timeout in seconds for related udev event processing to settle down.
 *
 * Execute the trigger, causing the synthesized udev events to be generated
 * for all devices included in the trigger and wait for all the related udev
 * event processing in udevd to settle down. Return if the settle does not
 * happen within specified timeout.
 *
 * Returns: 0 on success, -ETIMEDOUT on timeout, negative error value for any other error.
 */
_public_ int udev_trigger_execute_with_settle(struct udev_trigger *udev_trigger, unsigned int timeout_sec) {
        assert_return(udev_trigger, -EINVAL);

        return sd_device_trigger_execute_with_settle(udev_trigger->trigger, timeout_sec);
}
